[{"title":"__declspec关键字详解","date":"2018-03-13T09:51:15.000Z","path":"post/16cae89c.html","text":"__declspec用于指定所给定类型的实例的与Microsoft相关的存储方式。其它的有关存储方式的修饰符如static与extern等是C和C++语言的ANSI规范，而__declspec是一种扩展属性的定义。扩展属性语法简化并标准化了C和C++语言关于Microsoft的扩展。 用法：1__declspec ( extended-decl-modifier ) extended-decl-modifier参数如下，可同时出现，中间有空格隔开:12345678910111213141516171819202122232425262728293031323334353637align （C++）allocateappdomaindeprecated （C++）dllimportdllexportjitintrinsicnaked （C++）noaliasnoinlinenoreturnnothrow （C++）novtableprocessproperty（C++）restrictselectanythreaduuid（C++） 1.declspec关键字应该出现在简单声明的前面。对于出现在*或&amp;后面或者变量声明中标识符的前面的declspec，编译器将忽略并且不给出警告。 2.要注意区分__declspec是修饰类型还是修饰变量： declspec(align(8)) struct Str b;修饰的是变量b。其它地方定义的struct Str类型的变量将不受declspec(align(8))影响。 declspec(align(8)) struct Str {};修饰的是struct Str类型。所有该类型的变量都受declspec(align(8))影响。 align： 格式：1__declspec(align(n)) declarator 其中，n是对齐参数，其有效值是的整数次幂（从到字节），如，，，，或。参数declarator是要设置对齐方式的数据。 1.使用declspec(align(n))来精确控制用户自定义数据的对齐方式。你可以在定义struct，union，class或声明变量时使用declspec(align(n))。 2.不能为函数参数使用__declspec(align(n))。 3.如果未使用__declspec(align(#))，编译器将根据数据大小按自然边界对齐。如字节整数按字节边界对齐；字节double按字节边界对齐。类或结构体中的数据，将取数据本身的自然对齐方式和#pragma pack(n)设置的对齐系数中的最小值进行对齐。 4.__declspec(align(n))和#pragma pack(n)是一对兄弟，前者规定了对齐系数的最小值，后者规定了对齐系数的最大值。 5.当两者同时出现时，前者拥有更高的优先级。即，当两者同时出现且值矛盾时，后者将不起作用。 6.当变量size大于等于#pragma pack(n)指定的n，而且declspec(align(n))指定的数值n比对应类型长度小的时候，这个declspec(align(n))指定将不起作用。 7.当#pragma pack(n)指定的值n大于等于所有数据成员size的时候，这个值n将不起作用。 allocate： 格式：1__declspec(allocate(&quot;segname&quot;)) declarator 为数据指定存储的数据段。数据段名必须为以下列举中的一个：1234567891011121314151617code_segconst_segdata_seginit_segsectionappdomain：指定托管程序中的每个应用程序域都要有一份指定全局变量或静态成员变量的拷贝。deprecated：与#pragma deprecated()的作用相同。用于指定函数的某个重载形式是不推荐的。当在程序中调用了被deprecated修饰的函数时，编译器将给出C4996警告，并且可以指定具体的警告信息。该警告信息可以来源于定义的宏。 例如：1234567891011121314151617181920212223// compile with: /W3#define MY_TEXT \"function is deprecated\"void func1(void) &#123;&#125;__declspec(deprecated) void func1(int) &#123;&#125;__declspec(deprecated(\"** this is a deprecated function **\")) void func2(int) &#123;&#125;__declspec(deprecated(MY_TEXT)) void func3(int) &#123;&#125;int main() &#123; func1(); func1(1); // C4996，警告信息：warning C4996: 'func1': was declared deprecated func2(1); // C4996，警告信息：warning C4996: 'func2': ** this is a deprecated function ** func3(1); // C4996，警告信息：warning C4996: 'func3': function is deprecated&#125; dllimport，dllexport： 格式：123__declspec( dllimport ) declarator__declspec( dllexport ) declarator 分别用来从dll导入函数，数据，或对象以及从dll中导出函数，数据，或对象。相当于定义了dll的接口，为它的客户exe或dll定义可使用的函数，数据，或对象。 将函数声明成dllexport就可以免去定义模块定义(.DEF)文件。 dllexport代替了 __export关键字。 被声明为dllexport的C++函数导出时的函数名将会按照C++规则经过处理。如果要求不按照C++规则进行名字处理，请使用.def文件或使用extern “C”。 jitintrinsic： 格式：__declspec(jitintrinsic) 用于标记一个函数或元素是位通用语言运行时(CLR)。主要用于Microsoft提供的某些库中。 使用jitintrinsic会在函数签名中加入MODOPT(IsJitIntrinsic)。 naked： 格式：__declspec(naked) declarator 此关键字仅用于x86系统，多用于虚拟设备驱动。此关键字可以使编译器在生成代码时不包含任何注释或标记。仅可以对函数的定义使用，不能用于数据声明、定义，或者函数的声明。 noalias： 仅适用于函数，它指出该函数是半纯粹的函数。半纯粹的函数是指仅引用或修改局部变量、参数和第一层间接参数。它是对编译器的一个承诺，如果该函数引用全局变量或第二层间接指针参数，则编译器会生成中断应用程序的代码。 restrict： 格式：__declspec(restrict) return_type f(); 仅适用于返回指针的函数声明或定义，如，CRT的malloc函数：declspec(restrict) void *malloc(size_t size);它告诉编译器该函数返回的指针不会与任何其它的指针混淆。它为编译器提供执行编译器优化的更多信息。对于编译器来说，最大的困难之一是确定哪些指针会与其它指针混淆，而使用这些信息对编译器很有帮助。有必要指出，这是对编译器的一个承诺，编译器并不对其进行验证。如果您的程序不恰当地使用declspec(restrict)，则该程序的行为会不正确。 noinline： 因为在类定义中定义的成员函数默认都是inline的，__declspec(naked)用于显式指定类中的某个函数不需要inline(内联)。如果一个函数很小而且对系统性能影响不大，有必要将其声明为非内敛的。例如，用于处理错误情况的函数。 noreturn： 一个函数被declspec(noreturn)所修饰，那么它的含义是告诉编译器，这个函数不会返回，其结果是让编译器知道被修饰为declspec(noreturn)的函数之后的代码不可到达。 如果编译器发现一个函数有无返回值的代码分支，编译器将会报C4715警告，或者C2202错误信息。如果这个代码分支是因为函数不会返回从而无法到达的话，可以使用约定__declspec(noreturn)来避免上述警告或者错误。 将一个期望返回的函数约定为__declspec(noreturn)将导致未定义的行为。 在下面的这个例子中，main函数没有从else分支返回，所以约定函数fatal为__declspec(noreturn)来避免编译或警告信息。1234567891011121314151617__declspec(noreturn) extern void fatal () &#123;&#125;int main() &#123;if(1) return 1;else if(0) return 0;else fatal();&#125; nothrow: 格式：return-type __declspec(nothrow) [call-convention] function-name ([argument-list]) 可用于函数声明。告诉编译器被声明的函数以及函数内部调用的其它函数都不会抛出异常。 novtable： 可用于任何类声明中，但最好只用于纯接口类，即类本身从不实例化。此关键字的声明将阻止编译器对构造和析构函数的vfptr的初始化。可优化编译后代码大小。 如果试图实例化一个用__declspec(novtable)声明的类然后访问类中成员，则会在运行时产生访问错误(access violation，即AV)。 process： 表示你的托管应用程序进程应该拥有一份指定全局变量，静态成员变量，或所有应用程序域共享的静态本地变量的拷贝。在使用/clr:pure进行编译时，应该使用 __declspec(process)，因为使用/clr:pure进行编译时，在默认情况下，每个应用程序域拥有一份全局和静态变量的拷贝。在使用/clr进行编译时，不必使用__declspec(process)，因为使用/clr进行编译时，在默认情况下，每个进程有一份全局和静态变量的拷贝。 只有全局变量，静态成员变量，或本地类型的本地静态变量可以用__declspec(process)修饰。 在使用/clr:pure进行编译时，被声明为__declspec(process)的变量同时也应该声明为const类型。 如果想每个应用程序域拥有一份全局变量的拷贝时，请使用appdomain。 property： 格式：12345__declspec( property( get=get_func_name ) ) declarator__declspec( property( put=put_func_name ) ) declarator__declspec( property( get=get_func_name, put=put_func_name ) ) declarator 该属性可用于类或结构定义中的非静态“虚数据成员”。实际上就是做了一个映射，把你的方法映射成属性，以供访问。get和put就是属性访问的权限，一个是读的权限，一个是写的权限。当编译器看到被property修饰的数据成员出现在成员选择符(“.” 或”-&gt;”)的右边的时候，它将把该操作转换成get或put方法。该修饰符也可用于类或结构定义中的空数组。 用法如下：1234567891011121314151617181920212223242526272829struct S &#123; int i; void putprop(int j) &#123; i = j; &#125; int getprop() &#123; return i; &#125; __declspec(property(get = getprop, put = putprop)) int the_prop;&#125;;int main() &#123; S s; s.the_prop = 5; return s.the_prop;&#125; selectany： 格式：__declspec(selectany) declarator 在MFC，ATL的源代码中充斥着declspec(selectany)的声明。selectany可以让我们在.h文件中初始化一个全局变量而不是只能放在.cpp中。比如有一个类，其中有一个静态变量，那么我们可以在.h中通过类似declspec(selectany) type class::variable = value;这样的代码来初始化这个全局变量。既是该.h被多次include，链接器也会为我们剔除多重定义的错误。对于template的编程会有很多便利。 用法如下：1234567891011121314151617181920212223__declspec(selectany) int x1=1; //正确，x1被初始化，并且对外部可见const __declspec(selectany) int x2 =2; //错误，在C++中，默认情况下const为static；但在C中是正确的，其默认情况下const不为staticextern const __declspec(selectany) int x3=3; //正确，x3是extern const，对外部可见extern const int x4;const __declspec(selectany) int x4=4; //正确，x4是extern const，对外部可见extern __declspec(selectany) int x5; //错误，x5未初始化，不能用__declspec(selectany)修饰class X &#123;public:X(int i)&#123;i++;&#125;;int i;&#125;;__declspec(selectany) X x(1); //正确，全局对象的动态初始化 thread： 格式：__declspec(thread) declarator 声明declarator为线程局部变量并具有线程存储时限，以便链接器安排在创建线程时自动分配的存储。 线程局部存储(TLS)是一种机制，在多线程运行环境中，每个线程分配自己的局部数据。在标准多线程程序中，数据是在多个线程间共享的，而TLS是一种为每个线程分配自己局部数据的机制。 该属性只能用于数据或不含成员函数的类的声明和定义，不能用于函数的声明和定义。 该属性的使用可能会影响DLL的延迟载入。 该属性只能用于静态数据，包括全局数据对象(static和extern)，局部静态对象，类的静态数据成员；不能用于自动数据对象。 该属性必须同时用于数据的声明和定义，不管它的声明和定义是在一个文件还是多个文件。 __declspec(thread)不能用作类型修饰符。 如果在类声明的同时没有定义对象，则__declspec(thread)将被忽略，例如：12345678910111213// compile with: /LD__declspec(thread) class X&#123;public: int I;&#125; x; //x是线程对象X y; //y不是线程对象 下面两个例子从语义上来说是相同的：1234567891011121314151617__declspec(thread) class B &#123;public: int data;&#125; BObject; //BObject是线程对象class B2 &#123;public: int data;&#125;;__declspec(thread) B2 BObject2; // BObject2是线程对象 uuid： 格式：__declspec( uuid(“ComObjectGUID”) ) declarator 将具有唯一标识符号的已注册内容声明为一个变量，可使用__uuidof()调用。 用法如下：123struct __declspec(uuid(\"00000000-0000-0000-c000-000000000046\")) IUnknown;struct __declspec(uuid(\"&#123;00020400-0000-0000-c000-000000000046&#125;\")) IDispatch; 原文链接：http://hi.baidu.com/baiyw920/blog/item/a06ddb986314fd0f6e068c0c.html – end","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://amyge.com/blog/tags/C-C/"}]},{"title":"访问URL时传入另一个URL作为参数","date":"2018-03-13T09:30:04.000Z","path":"post/4e59e7c5.html","text":"有的时候我们需要在访问一个URL时传入另一个URL，同时给后面的URL带参数，这种情况下很容把参数传给第一个URL（实际上浏览器也是这么解析的），这种情况怎么办呢比如，现在要访问地址：1http://192.168.1.1/login.html?a=1&amp;b=2&amp;url=/device.html?c=3&amp;d=4 按照我们的本意，c=3&amp;d=4这两个参数都是要传给第二个URL的，但实际上，d=4 这个参数会被当做是访问 login.html 时的参数，而不是 device.html 的参数。 解决办法： 对url 参数内容进行编码，如下：1http://192.168.1.1/login.html?a=1&amp;b=2&amp;url=escape(/device.html?c=3&amp;d=4) 后端获取的时候再使用 unescape() 进行解码，就能拿到完整的路径及参数了 But，对于已经发布版本的项目来说，不能修改后端代码，咋整？ 简单看了一下escape()的实现，发现它仅仅只是对部分特殊字符进行转义123456&lt;script type=\"text/javascript\"&gt;document.write(escape(\"Visit W3School!\") + \"&lt;br /&gt;\")document.write(escape(\"?!=()#%&amp;\"))&lt;/script&gt; 输出：12Visit%20W3School%21%3F%21%3D%28%29%23%25%26 感觉有点草率啊~~~既然这样，那为啥咱不直接手动输入转义字符呢？比如：1http://192.168.1.1/login.html?a=1&amp;b=2&amp;url=/device.html?c=3%26d=4 是的，确实可以，而且可以增加参数。1http://192.168.1.1/login.html?a=1&amp;b=2&amp;url=/device.html?c=3%26d=4%26e=5 在浏览器中直接输入，或者在前端代码中访问，都是可以的 多看源码，多折腾，少逛头条，和抖音","tags":[{"name":"javascript","slug":"javascript","permalink":"http://amyge.com/blog/tags/javascript/"}]},{"title":"linux尽量避免使用system()函数,用popen()代替","date":"2018-03-13T09:19:24.000Z","path":"post/9ca378c1.html","text":"linux尽量避免使用system。曾经的曾经，被system()函数折磨过，之所以这样，是因为对system()函数了解不够深入。只是简单的知道用这个函数执行一个系统命令，这远远不够，它的返回值、它所执行命令的返回值以及命令执行失败原因如何定位，这才是重点。当初因为这个函数风险较多，故抛弃不用，改用其他的方法。这里先不说我用了什么方法，这里必须要搞懂system()函数，因为还是有很多人用了system()函数，有时你不得不面对它。 先来看一下system()函数的简单介绍：123#include &lt;stdlib.h&gt;int system(const char *command);system() executes a command specified in command by calling /bin/sh -c command, and returns after the command has been completed. During execution of the command, SIGCHLD will be blocked, and SIGINT and SIGQUIT will be ignored. system()函数调用/bin/sh来执行参数指定的命令，/bin/sh 一般是一个软连接，指向某个具体的shell，比如bash，-c 选项是告诉shell从字符串 command 中读取命令；在该command执行期间，SIGCHLD是被阻塞的，好比在说：hi，内核，这会不要给我送SIGCHLD信号，等我忙完再说；在该command执行期间，SIGINT和SIGQUIT是被忽略的，意思是进程收到这两个信号后没有任何动作。 再来看一下system()函数返回值：12The value returned is -1 on error (e.g. fork(2) failed), and the return status of the command otherwise. This latter return status is in the format specified in wait(2). Thus, the exit code of the command will be WEXITSTATUS(status). In case /bin/sh could not be executed, the exit status will be that of a command that does exit(127).If the value of command is NULL, system() returns nonzero if the shell is available, and zero if not. 为了更好的理解system()函数返回值，需要了解其执行过程，实际上system()函数执行了三步操作： 1.fork一个子进程； 2.在子进程中调用exec函数去执行command； 3.在父进程中调用wait去等待子进程结束。 对于fork()失败，system()函数返回-1。如果exec()执行成功，也即command顺利执行完毕，则返回command通过exit或return返回的值。（注意，command顺利执行不代表执行成功，比如command：&quot;rm debuglog.txt&quot;，不管文件存不存在该command都顺利执行了）如果exec()执行失败，也即command没有顺利执行，比如被信号中断，或者command命令根本不存在，system()函数返回127.如果command为NULL，则system()函数返回非0值，一般为1. 看一下system()函数的源码看完这些，我想肯定有人对system()函数返回值还是不清楚，看源码最清楚，下面给出一个system()函数的实现：123456789101112131415161718192021222324252627282930int system(const char * cmdstring)&#123; pid_t pid; int status; if(cmdstring == NULL) &#123; return (1); //如果cmdstring为空，返回非零值，一般为1 &#125; if((pid = fork())&lt;0) &#123; status = -1; //fork失败，返回-1 &#125; else if(pid == 0) &#123; execl(\"/bin/sh\", \"sh\", \"-c\", cmdstring, (char *)0); _exit(127); // exec执行失败返回127，注意exec只在失败时才返回现在的进程，成功的话现在的进程就不存在啦~~ &#125; else //父进程 &#123; while(waitpid(pid, &amp;status, 0) &lt; 0) &#123; if(errno != EINTR) &#123; status = -1; //如果waitpid被信号中断，则返回-1 break; &#125; &#125; &#125; return status; //如果waitpid成功，则返回子进程的返回状态&#125; 仔细看完这个system()函数的简单实现，那么该函数的返回值就清晰了吧，那么什么时候system()函数返回0呢？只在command命令返回0时。 看一下该怎么监控system()函数执行状态这里给我出的做法：1234567891011121314151617181920212223int status;if(NULL == cmdstring) //如果cmdstring为空趁早闪退吧，尽管system()函数也能处理空指针&#123; return XXX;&#125;status = system(cmdstring);if(status &lt; 0)&#123; printf(\"cmd: %s\\t error: %s\", cmdstring, strerror(errno)); // 这里务必要把errno信息输出或记入Log return XXX;&#125;if(WIFEXITED(status))&#123; printf(\"normal termination, exit status = %d\\n\", WEXITSTATUS(status)); //取得cmdstring执行结果&#125;else if(WIFSIGNALED(status))&#123; printf(\"abnormal termination,signal number =%d\\n\", WTERMSIG(status)); //如果cmdstring被信号中断，取得信号值&#125;else if(WIFSTOPPED(status))&#123; printf(\"process stopped, signal number =%d\\n\", WSTOPSIG(status)); //如果cmdstring被信号暂停执行，取得信号值&#125; 到于取得子进程返回值的相关介绍可以参考另一篇 文章 system()函数用起来很容易出错，返回值太多，而且返回值很容易跟command的返回值混淆。这里推荐使用popen()函数替代，关于popen()函数的简单使用也可以通过上面的链接查看。 popen()函数较于system()函数的优势在于使用简单，popen()函数只返回两个值：成功返回子进程的status，使用WIFEXITED相关宏就可以取得command的返回结果；失败返回-1，我们可以使用perro()函数或strerror()函数得到有用的错误信息。 这篇文章只涉及了system()函数的简单使用，还没有谈及SIGCHLD、SIGINT和SIGQUIT对system()函数的影响，事实上，之所以今天写这篇文章，是因为项目中因有人使用了system()函数而造成了很严重的事故。现像是system()函数执行时会产生一个错误：“No child processes”。 关于这个错误的分析，感兴趣的朋友可以看一下这篇文章 原文链接： http://blog.csdn.net/shanzhizi/article/details/9053953","tags":[{"name":"C/C++","slug":"C-C","permalink":"http://amyge.com/blog/tags/C-C/"}]},{"title":"jQuery.html()和innerHTML在IE8中失效","date":"2018-03-12T12:26:43.000Z","path":"post/e7d93b0c.html","text":"代码如下： 在IE8上运行起来，下拉框中任何选项都没有，加打印发现&lt;select&gt;块中没有任何数据正常现象应该是有两个选项才对而在IE11上又能正常显示，看来是在IE8中 opt_html 中的内容没有填充进去 把1$(\"MDVR_MAIN_[CH]_BRM\").html(opt_html); 换成原生写法1document.getElementById('MDVR_MAIN_[CH]_BRM').innerHTML = opt_html; 现象跟之前一样，但是加打印发现&lt;select&gt;块中有数据，如下：1CBR&lt;/option&gt;&lt;option value=\"1\"&gt;VBR&lt;/option&gt; ？？？什么鬼？？？ 为什么数据不完整？ 一番百度，google后发现，原来IE8 及以下（IE7、IE6）版本对 innerHTML 设置的内容会做检查，只有当填充的内容为一个完整的html元素时才能加载成功 根据这个思路，代码修改如下：即用一个完整的标签包含想要添加的内容正常运行！ 看到有网友说 append() 接口也有这种情况，以后遇到这类情况都要注意点咯 话说 IE 的坑真的很多，前端开发最痛苦的事就是要兼容IE浏览器吧，哈哈，幸好，我是后端攻城狮 -END-","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://amyge.com/blog/tags/jQuery/"}]},{"title":"开篇之作","date":"2018-03-12T12:06:23.000Z","path":"post/d49fef81.html","text":"这个博客搭建起来还真是不容易，走了好多弯路，甚至都打算纯手写实现了（维护起来太麻烦了）主要是没有方向，幸亏加了一个交流群，群主是个老司机，指点了一下，豁然开朗，然后一个小时就搭好了（论方向的重要性…）前两天一直在想一件事，就是页面的URL改变了，但是界面内容只有部分改变了，比如页面整体布局、标题栏、广告信息(如果有的话)是一直不变的，只有文章内容在改变，这是怎么实现的，难道每个文章界面都把标题栏、广告信息什么的加上？这显然不可能，维护起来巨麻烦。看网上说&lt;iframe&gt;标签可以干这事，它确实可以加载外部界面，但是URL并不会改变啊，是我使用姿势不对么？还有一种办法是使用#符号，表示一个位置，可以起到这种作用，目前公司项目就是用的这种办法，貌似不主流啊，除了twitter最近用上了，没见哪里用了这事到现在还没想明白，没办法，知识面太窄，看到这篇文章的大神，如果有知道的，请告诉我，感激不尽！ 总结一下，还是得多加群，多进论坛，多问。 Mark：主题配置BlueLake博客主题的详细配置主页Hexo","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://amyge.com/blog/tags/杂谈/"}]}]